use crate::{position::Position, token::Token};
use std::{io, num::ParseIntError, path::PathBuf};
use thiserror::Error;

/// TokenError defines an error generated by the Tokenizer
#[derive(Error, Debug, PartialEq)]
#[error("...")]
pub enum TokenError {
    #[error("Invalid delimiter {0}")]
    InvalidStringDelimiter(char),

    #[error("Invalid end delimiter {0}")]
    MissingEndDelimiter(char),

    #[error("Unexpected char {0}")]
    UnexpectedChar(char),
}

/// ParseError defines an error generated when parsing a file
#[derive(Error, Debug, PartialEq)]
#[error("...")]
pub enum ParseError {
    #[error("Unexpected end of file")]
    EOF,

    #[error("proto version {0} not supported")]
    ProtoSyntaxNotSupported(String),

    #[error("package already set")]
    PackageAlreadySet,

    #[error("unexpected top-level token: {0}")]
    UnexpectedTopLevelToken(Token),

    #[error("unexpected message token: {0}")]
    UnexpectedMessageToken(Token),

    #[error("unexpected token: \"{found}\" expected one of {expected:?}")]
    UnexpectedToken { found: Token, expected: Vec<Token> },

    #[error("unexpected string: {0}")]
    UnexpectedString(Token),

    #[error("failed to parse field id: {0}")]
    ParseFieldId(ParseIntError),

    #[error("failed to parse enum value: {0}")]
    ParseEnumValue(ParseIntError),

    #[error("{0}")]
    TokenError(#[from] TokenError),
}

#[derive(Error, Debug)]
#[error("...")]
pub enum ResolveError {
    #[error("Failed to resolve field: {type_name} {field}")]
    UnresolvedField { type_name: String, field: String },

    #[error("Failed to resolve rpc type: {_0}")]
    UnresolvedRpcType(String),
}

impl ResolveError {
    pub fn to_parse_file_error(self, path: PathBuf) -> ParseFileError {
        return ParseFileError::Resolve(path, self);
    }
}

/// ParseFileError defines an error generated while reading and parsing a file
#[derive(Error, Debug)]
#[error("...")]
pub enum ParseFileError {
    #[error("Failed to read file {0}. {1}")]
    Read(PathBuf, io::Error),

    #[error("File {0}, {1}")]
    Resolve(PathBuf, ResolveError),

    #[error("{0}")]
    ParseError(String),

    FileAlreadyParsed,
}

impl ParseFileError {
    /// Returns a ParseFileError by using the file's content and current position
    /// to add some context to the ParseError
    pub fn from_parse_error(
        error: ParseError,
        file_name: PathBuf,
        content: &str,
        position: Position,
    ) -> ParseFileError {
        let line_number = position.line;
        let line_number_width = line_number.to_string().len();
        let show_lines = std::cmp::min(position.line, 3);

        let lines = content
            .split('\n')
            .skip(position.line - show_lines)
            .take(show_lines)
            .enumerate()
            .map(|(i, v)| {
                format!(
                    "{:line$} | {}",
                    line_number - (show_lines - i - 1),
                    v,
                    line = line_number_width
                )
            })
            .collect::<Vec<String>>()
            .join("\n");

        let padding = (0..position.column + line_number_width + 1)
            .map(|_| ' ')
            .collect::<String>();

        ParseFileError::ParseError(format!(
            "Failed to parse {}\n{}\n{}{}",
            file_name.display(),
            lines,
            padding,
            error
        ))
    }
}
